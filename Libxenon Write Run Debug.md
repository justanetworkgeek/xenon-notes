# Libxenon Write Run Debug

These are the steps I follow to write, run, and effectively debug Libxenon applications. I write this to hopefully empower would be 360 homebrew developers in 2025 some tips I have gathered over the years.

## Stack traces

Reading any stack traces that are displayed on the scary red screen is critical to successful debugging of custom apps. Taking a picture and reading the trace at the bottom of the page will help to understand exactly where a program failed. Breakpoints can also be inserted but this requires a hardware UART connected or other code written to handle the events. 

A UART makes the stack traces easier to copy and paste and feed to readelf to pinpoint exact failures. Otherwise the telnet_console_init() function within console.h of libxenon works fine and can also be used to capture stack traces. 

### Telnet 

Adding anywhere in the libxenon code `telnet_console_init()` where you are trying to debug (or before a main loop) will **redirect** console output to telnet. `network_init()` and `network_poll()` must have been called as well before the telnet console can be used. The console can be connected to on port 23/tcp. It does not really accept any commands, but parsing stdin can read sent characters from a connected client. This is no-OS territory so all functionality must be implemented but having a simple telnet connection is very useful.

Telnet console initializations do not carry through between libxenon programs. It must be re-initialized in each program.

### Readelf and friends

`xenon-readelf` can be used to help interpret stack traces. The elf cannot be run on a PC without a cross compiled GDB (explore this soon) - but it can be analyzed. Man page for readelf is necessary to make sense of things but it starts to come together quickly with practice.

There is a `.map` file generated by compiling which will contain some section information.

You can even check out what actual powerpc64 instructions are being executed by the code with `xenon-objdump`.

All of these things carry over from regular ol' C development but I figure it worth mentioning that these same features are available for xenon
as a development platform. Combining these tools gives a lot of insight into what is being executed when and what could have failed within a large program.

## TFTP Booting

XeLL has supported booting files via TFTP forever. This is how I use it, roughly.

- On any Linux disto install a tftp server. I use tftpd-hpa.
- Whatever server is chosen make sure to set up a directory `/tftpboot` which is owned by nobody:nogroup and also chmod 7777 (r/w/x by anyone from anywhere).
- Port 69 must be open on the server's firewall and that firewall must be reloaded.
- XeLL supports some static filenames. Put any of them in /tftpboot containing any type of binary executable. 
- If the chosen tftp server supports any type of insecure mode, enable it.
- tftp server logs will help - via journald or other means as the server os supports.


Makefiles can have rules added to support building and cleaning to TFTP server directory:
```
run: $(BUILD) $(OUTPUT).elf32
	cp $(OUTPUT).elf32 $(TFTPROOT)/xenon
	$(PREFIX)strip $(OUTPUT).elf32
	gzip -n9 -f $(OUTPUT).elf32 -S.gz
```
Some other static filenames can be chosen too but the first one found will be used.